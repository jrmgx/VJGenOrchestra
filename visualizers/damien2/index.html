<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>VibeCode v2.1 - Bitmap Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; color: #0f0; pointer-events: none; }
        #controls { 
            position: absolute; right: 20px; top: 20px; z-index: 10; 
            display: grid; grid-template-columns: 1fr; gap: 5px; pointer-events: auto;
        }
        .btn-group { display: flex; gap: 2px; }
        button { 
            padding: 10px; background: #222; border: 1px solid #0f0; color: #0f0; 
            cursor: pointer; text-align: left; font-size: 11px; flex-grow: 1;
        }
        button.active { background: #0f0; color: #000; font-weight: bold; }
        button.upload-btn { background: #555; border-color: #fff; color: #fff; flex-grow: 0; }
        .start-layer { 
            position: fixed; inset: 0; background: #000; display: flex; 
            justify-content: center; align-items: center; z-index: 100; 
        }
        #startBtn { padding: 20px 40px; font-size: 20px; background: #0f0; border: none; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div class="start-layer" id="overlay">
        <button id="startBtn">INITIALISER VIBECODE v2.1</button>
    </div>

    <div id="ui">
        <h1>VIBECODE v2.1</h1>
        <div id="status">AUDIO: STANDBY</div>
    </div>

    <div id="controls"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, analyzer, dataArray;
        const modules = [];
        const textureLoader = new THREE.TextureLoader();

        const moduleConfigs = [
            { id: 1, name: "KICK SPHERE", type: "sphere", color: 0x00ffff },
            { id: 2, name: "BASS TUNNEL", type: "tunnel", color: 0xff0055 },
            { id: 3, name: "HIGH STARS", type: "particles", color: 0xffffff },
            { id: 4, name: "MID RINGS", type: "rings", color: 0xffff00 },
            { id: 5, name: "GLITCH BOX", type: "cube", color: 0x00ff00 },
            { id: 6, name: "LIGHT LEAK", type: "leak", color: 0xff4400 },
            { id: 7, name: "FLOOR GRID", type: "grid", color: 0x4444ff },
            { id: 8, name: "WAVE LINE", type: "line", color: 0xffffff },
            { id: 9, name: "GHOST SPIRAL", type: "spiral", color: 0xaa00ff },
            { id: 10, name: "IMAGE BITMAP", type: "bitmap", color: 0xffffff }
        ];

        function createModule(cfg) {
            let group = new THREE.Group();
            group.visible = false;

            if (cfg.type === "sphere") {
                const m = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true }));
                group.add(m);
            } 
            else if (cfg.type === "tunnel") {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 100, 16, 1, true), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true, side: THREE.DoubleSide }));
                m.rotation.x = Math.PI/2;
                group.add(m);
            }
            else if (cfg.type === "particles") {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(1500 * 3).map(() => (Math.random() - 0.5) * 50);
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                group.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: cfg.color, size: 0.1 })));
            }
            else if (cfg.type === "rings") {
                for(let i=0; i<6; i++) {
                    group.add(new THREE.Mesh(new THREE.TorusGeometry(i*1.2+2, 0.03, 8, 50), new THREE.MeshBasicMaterial({ color: cfg.color })));
                }
            }
            else if (cfg.type === "cube") {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true })));
            }
            else if (cfg.type === "leak") {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshBasicMaterial({ color: cfg.color, transparent: true, opacity: 0, blending: THREE.AdditiveBlending }));
                m.position.z = 5; group.add(m);
            }
            else if (cfg.type === "grid") {
                const m = new THREE.GridHelper(100, 30, cfg.color, cfg.color);
                m.position.y = -8; group.add(m);
            }
            else if (cfg.type === "line") {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(25, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: cfg.color })));
            }
            else if (cfg.type === "spiral") {
                group.add(new THREE.Mesh(new THREE.TorusKnotGeometry(2, 0.4, 100, 16), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true })));
            }
            else if (cfg.type === "bitmap") {
                // Plane avec beaucoup de segments pour la déformation (64x64)
                const mat = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide, shininess: 100 });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(16, 10, 64, 64), mat);
                group.add(mesh);
                
                // Input caché
                const input = document.createElement('input');
                input.type = 'file'; input.accept = 'image/*';
                input.onchange = (e) => {
                    const url = URL.createObjectURL(e.target.files[0]);
                    textureLoader.load(url, (t) => { 
                        mat.map = t; mat.displacementMap = t; mat.needsUpdate = true; 
                    });
                };
                group.userData.input = input;
            }

            scene.add(group);
            return { group, type: cfg.type };
        }

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 0, 10); scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            const ctrlContainer = document.getElementById('controls');
            moduleConfigs.forEach(cfg => {
                const mod = createModule(cfg);
                modules.push(mod);

                const wrapper = document.createElement('div');
                wrapper.className = 'btn-group';

                const btn = document.createElement('button');
                btn.innerText = `[OFF] ${cfg.name}`;
                btn.onclick = () => {
                    mod.group.visible = !mod.group.visible;
                    btn.classList.toggle('active');
                    btn.innerText = mod.group.visible ? `[ON] ${cfg.name}` : `[OFF] ${cfg.name}`;
                };
                wrapper.appendChild(btn);

                if(cfg.type === "bitmap") {
                    const up = document.createElement('button');
                    up.innerText = "JPG"; up.className = "upload-btn";
                    up.onclick = () => mod.group.userData.input.click();
                    wrapper.appendChild(up);
                }

                ctrlContainer.appendChild(wrapper);
            });

            await setupAudio();
            animate();
        }

        async function setupAudio() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const ctx = new AudioContext();
            const source = ctx.createMediaStreamSource(stream);
            analyzer = ctx.createAnalyser();
            analyzer.fftSize = 256;
            source.connect(analyzer);
            dataArray = new Uint8Array(analyzer.frequencyBinCount);
            document.getElementById('status').innerText = "AUDIO: CONNECTED";
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!analyzer) return;

            analyzer.getByteFrequencyData(dataArray);
            const bass = dataArray[2] / 255;
            const mid = dataArray[20] / 255;
            const high = dataArray[60] / 255;

            modules.forEach(m => {
                if (!m.group.visible) return;

                if (m.type === "sphere") {
                    m.group.scale.setScalar(1 + bass * 1.5);
                    m.group.rotation.y += 0.01 + mid * 0.05;
                }
                if (m.type === "tunnel") {
                    m.group.rotation.z += 0.005 + bass * 0.08;
                    m.group.position.z = (m.group.position.z + 0.1 + bass) % 20 - 10;
                }
                if (m.type === "bitmap") {
                    const mesh = m.group.children[0];
                    mesh.material.displacementScale = bass * 6; // Déformation relief
                    mesh.rotation.y = Math.sin(Date.now()*0.001) * 0.2;
                }
                if (m.type === "rings") {
                    m.group.children.forEach((r, i) => r.rotation.x += 0.01 * (i+1) + mid * 0.04);
                }
                if (m.type === "leak") {
                    m.group.children[0].material.opacity = bass > 0.85 ? 0.7 : m.group.children[0].material.opacity * 0.92;
                }
                if (m.type === "grid") {
                    m.group.position.z = (m.group.position.z + 0.2 + bass) % 20 - 10;
                }
                if (m.type === "cube") {
                    m.group.rotation.set(bass, mid, high);
                    m.group.scale.setScalar(0.5 + bass * 2.5);
                }
                if (m.type === "spiral") {
                    m.group.rotation.z += 0.02;
                    m.group.scale.setScalar(0.8 + mid * 2);
                }
            });

            if (bass > 0.9) {
                camera.position.x = (Math.random()-0.5)*0.6;
                camera.position.y = (Math.random()-0.5)*0.6;
            } else {
                camera.position.lerp(new THREE.Vector3(0,0,12), 0.1);
            }

            renderer.render(scene, camera);
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            init();
        });

        window.addEventListener('resize', () => {
            if(!renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>