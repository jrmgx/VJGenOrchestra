<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>VibeCode v2.7 - Roman Hill Exact Replica</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; color: #0f0; pointer-events: none; }
        #controls { position: absolute; right: 20px; top: 20px; z-index: 10; display: grid; gap: 5px; }
        button { padding: 10px; background: #222; border: 1px solid #0f0; color: #0f0; cursor: pointer; font-size: 11px; }
        button.active { background: #0f0; color: #000; font-weight: bold; box-shadow: 0 0 10px #0f0; }
        .start-layer { position: fixed; inset: 0; background: #000; display: flex; justify-content: center; align-items: center; z-index: 100; }
        #startBtn { padding: 20px 40px; font-size: 20px; background: #0f0; border: none; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div class="start-layer" id="overlay">
        <button id="startBtn">INITIALISER LE RENDU OPTIQUE</button>
    </div>

    <div id="ui">
        <h1>VIBECODE v2.7</h1>
        <div id="status">AUDIO: STANDBY</div>
    </div>

    <div id="controls"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, analyzer, dataArray;
        const modules = [];

        // --- SHADER AVANCÉ POUR L'EFFET DE MASQUAGE ET FRANGES ---
        const BokehShader = {
            uniforms: {
                uTime: { value: 0 },
                uBass: { value: 0 },
                uHigh: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying float vVisible;
                uniform float uBass;
                uniform float uTime;
                attribute float aSize;
                attribute vec3 aColor;
                varying vec3 vColor;

                void main() {
                    vColor = aColor;
                    // Mouvement organique individuel
                    vec3 pos = position;
                    pos.x += sin(uTime * 0.2 + position.z) * 2.0;
                    pos.y += cos(uTime * 0.15 + position.x) * 2.0;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    // Taille qui pompe avec les basses
                    gl_PointSize = aSize * (150.0 / -mvPosition.z) * (1.0 + uBass * 1.5);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform float uBass;
                varying vec3 vColor;

                void main() {
                    // Coordonnées du point (0.0 à 1.0)
                    vec2 uv = gl_PointCoord - vec2(0.5);
                    float dist = length(uv);
                    
                    // 1. Création de l'anneau (bord brillant, centre vide)
                    float ring = smoothstep(0.35, 0.4, dist) * smoothstep(0.5, 0.45, dist);
                    
                    // 2. EFFET DE MASQUAGE (L'occultation partielle que tu cherches)
                    // On crée un plan de coupe qui bouge pour "manger" la bulle
                    float maskValue = sin(gl_FragCoord.x * 0.01 + uTime) * cos(gl_FragCoord.y * 0.01);
                    float clip = smoothstep(-0.2, 0.5, maskValue + dist);
                    
                    // 3. Franges chromatiques sur le bord
                    vec3 finalColor = vColor;
                    if(dist > 0.43) finalColor *= vec3(1.2, 0.8, 1.5); // Bordure irisée
                    
                    float alpha = ring * clip * (0.5 + uBass);
                    
                    if (alpha < 0.01) discard;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `
        };

        function createModule(cfg) {
            let group = new THREE.Group();
            group.visible = false;

            if (cfg.type === "pureBokeh") {
                const count = 400;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);

                for(let i=0; i<count; i++) {
                    pos[i*3] = (Math.random()-0.5)*100;
                    pos[i*3+1] = (Math.random()-0.5)*100;
                    pos[i*3+2] = (Math.random()-0.5)*60;
                    
                    // Palette Roman Hill (Or, Cyan, Pourpre, Blanc)
                    const r = Math.random();
                    if(r < 0.3) { colors[i*3]=1.0; colors[i*3+1]=0.8; colors[i*3+2]=0.2; }
                    else if(r < 0.6) { colors[i*3]=0.2; colors[i*3+1]=0.9; colors[i*3+2]=1.0; }
                    else { colors[i*3]=0.8; colors[i*3+1]=0.2; colors[i*3+2]=1.0; }
                    
                    sizes[i] = Math.random() * 5 + 2;
                }

                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
                geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

                const mat = new THREE.ShaderMaterial({
                    uniforms: THREE.UniformsUtils.clone(BokehShader.uniforms),
                    vertexShader: BokehShader.vertexShader,
                    fragmentShader: BokehShader.fragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                group.add(new THREE.Points(geo, mat));
            } 
            else if (cfg.type === "sphere") {
                group.add(new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true })));
            }
            else if (cfg.type === "tunnel") {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 100, 16, 1, true), new THREE.MeshBasicMaterial({ color: cfg.color, wireframe: true, side: THREE.DoubleSide }));
                m.rotation.x = Math.PI/2; group.add(m);
            }

            scene.add(group);
            return { group, type: cfg.type };
        }

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const configs = [
                { name: "ULTRA BOKEH (REF)", type: "pureBokeh" },
                { name: "KICK SPHERE", type: "sphere", color: 0x00ffff },
                { name: "BASS TUNNEL", type: "tunnel", color: 0xff0055 }
            ];

            const ctrl = document.getElementById('controls');
            configs.forEach(cfg => {
                const mod = createModule(cfg);
                modules.push(mod);
                const btn = document.createElement('button');
                btn.innerText = `[OFF] ${cfg.name}`;
                btn.onclick = () => {
                    mod.group.visible = !mod.group.visible;
                    btn.classList.toggle('active');
                };
                ctrl.appendChild(btn);
            });

            await setupAudio();
            animate();
        }

        async function setupAudio() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const ctx = new AudioContext();
            const source = ctx.createMediaStreamSource(stream);
            analyzer = ctx.createAnalyser();
            analyzer.fftSize = 256;
            source.connect(analyzer);
            dataArray = new Uint8Array(analyzer.frequencyBinCount);
            document.getElementById('status').innerText = "AUDIO: CONNECTED";
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!analyzer) return;
            analyzer.getByteFrequencyData(dataArray);
            const bass = dataArray[2] / 255;
            const high = dataArray[80] / 255;
            const time = Date.now() * 0.001;

            modules.forEach(m => {
                if (!m.group.visible) return;
                if (m.type === "pureBokeh") {
                    const mat = m.group.children[0].material;
                    mat.uniforms.uTime.value = time;
                    mat.uniforms.uBass.value = bass;
                }
                if (m.type === "sphere") {
                    m.group.scale.setScalar(1 + bass);
                    m.group.rotation.y += 0.01;
                }
            });

            renderer.render(scene, camera);
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            init();
        });
    </script>
</body>
</html>